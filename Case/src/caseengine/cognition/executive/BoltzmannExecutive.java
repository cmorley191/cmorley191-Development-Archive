package caseengine.cognition.executive;

/**
 * An executive that uses a specialized controller to decide between selecting
 * the action with the highest predicted reinforcement and selecting an action
 * with a high yet non-maximum predicted reinforcement, for purposes of
 * innovation and exploration.
 * <p>
 * The executive contains an {@link ImpulseController} that dictates the balance
 * between maximum-reinforcement selection and exploratory selection. The
 * controller returns an "impulse resistance" for use during action selection
 * (see {@link ImpulseController#getImpulseResistance() the method} for
 * information about impulse resistance). In fact, when the resistance returned
 * is less than or equal to 0, the executive generates a new instance of
 * {@link GreedyExecutive} and concedes to its selection protocol.
 * <p>
 * The type is named after Ludwig Boltzmann of whose probability distribution
 * function the executive's selection protocol makes use.
 * 
 * @author Charlie Morley
 * 
 */
public class BoltzmannExecutive extends Executive {

	/**
	 * This executive's supplier of the impulse resistance that corresponds with
	 * the selection of exploratory actions versus maximum-reinforcement ones.
	 */
	private final ImpulseController impulseController;

	/**
	 * Constructs a new executive with the specified impulse controller.
	 * 
	 * @param impulseController
	 *            the controller that supplies this executive with impulse
	 *            resistance values during action selection
	 */
	public BoltzmannExecutive(ImpulseController impulseController) {
		this.impulseController = impulseController;
	}

	/**
	 * Returns this executive's impulse controller - the supplier of the impulse
	 * resistance that corresponds with the selection of exploratory actions
	 * versus maximum-reinforcement ones.
	 * 
	 * @return this executive's impulse controller
	 */
	public ImpulseController getImpulseController() {
		return impulseController;
	}

	/**
	 * {@inheritDoc}
	 * <p>
	 * The selection protocol of a {@code BoltzmannExecutive} returns a balance
	 * (over time) of exploratory and greedy action correlating with the impulse
	 * resistances returned by this executive's {@link ImpulseController}.
	 */
	@Override
	public int selectAction(double[] reinforcements) {
		if (super.selectAction(reinforcements) == -1)
			return -1;
		double impulseResistance = impulseController.getImpulseResistance();
		if (impulseResistance <= 0.001)
			return new GreedyExecutive().selectAction(reinforcements);
		double[] boltzmannConstants = new double[reinforcements.length];
		double total = 0.0;
		for (int i = 0; i < reinforcements.length; i++) {
			boltzmannConstants[i] = Math.pow(Math.E, reinforcements[i]
					/ impulseResistance);
			total += boltzmannConstants[i];
		}
		double choicePosition = Math.random() * total;
		for (int i = 0; i < reinforcements.length; i++) {
			choicePosition -= boltzmannConstants[i];
			if (choicePosition < 0)
				return i;
		}
		return reinforcements.length - 1;
	}

	/**
	 * A utility for {@code BoltzmannExecutives} that returns an
	 * "impulse resistance" for use in the executive's action selection
	 * protocol. (See {@link #getImpulseResistance()}).
	 * 
	 * @author Charlie Morley
	 *
	 */
	public static abstract class ImpulseController {

		/**
		 * Returns the impulse resistance generated by this impulse controller's
		 * internal protocols.
		 * <p>
		 * A higher resistance correlates with exploratory or innovative
		 * selections (selections of actions that may not have the highest
		 * immediate reinforcement but might lead to better long-term
		 * solutions), while a lower resistance correlates with greedy
		 * selections (selections of actions with the highest immediate
		 * reinforcement).
		 * 
		 * @return the impulse resistance generated by this controller's
		 *         protocols
		 */
		public abstract double getImpulseResistance();
	}

	/**
	 * An impulse controller that returns an unchanging value for impulse
	 * resistance.
	 * 
	 * @author Charlie Morley
	 *
	 */
	public final static class ConstantImpulseController extends
			ImpulseController {

		/**
		 * The value always returned by this impulse controller for impulse
		 * resistance.
		 */
		private double impulseResistance;

		/**
		 * Constructs a new controller that always returns the specified value
		 * for impulse resistance.
		 * 
		 * @param impulseResistance
		 *            the value to be returned for impulse resistance
		 */
		public ConstantImpulseController(double impulseResistance) {
			this.impulseResistance = impulseResistance;
		}

		/**
		 * {@inheritDoc}
		 * <p>
		 * The impulse resistance returned by a
		 * {@code ConstantImpulseController} is always the value that was passed
		 * to the controller's
		 * {@link ConstantImpulseController#ConstantImpulseController(double)
		 * constructor}.
		 */
		@Override
		public double getImpulseResistance() {
			return impulseResistance;
		}
	}

	/**
	 * An impulse controller that returns the value stored in a modifiable
	 * instance variable for impulse resistance. The value can be set at any
	 * time using {@link DynamicImpulseController#setImpulseResistance(double)}.
	 * 
	 * @author Charlie Morley
	 *
	 */
	public final static class DynamicImpulseController extends
			ImpulseController {

		/**
		 * The current value to be returned for impulse resistance.
		 */
		private double impulseResistance;

		/**
		 * Constructs a new controller with the specified initial value to be
		 * returned for impulse resistance.
		 * 
		 * @param initialImpulseResistance
		 *            the initial value to be returned for impulse resistance
		 */
		public DynamicImpulseController(double initialImpulseResistance) {
			impulseResistance = initialImpulseResistance;
		}

		/**
		 * Sets a new value to be returned for impulse resistance.
		 * 
		 * @param impulseResistance
		 *            the value to be returned for impulse resistance
		 */
		public void setImpulseResistance(double impulseResistance) {
			this.impulseResistance = impulseResistance;
		}

		/**
		 * {@inheritDoc}
		 * <p>
		 * The impulse resistance returned by a {@code DynamicImpulseController}
		 * is the value currently stored in the controller (set by the
		 * {@link DynamicImpulseController#DynamicImpulseController(double)
		 * constructor} or {@link #setImpulseResistance(double) setter}).
		 */
		@Override
		public double getImpulseResistance() {
			return impulseResistance;
		}

	}
}
